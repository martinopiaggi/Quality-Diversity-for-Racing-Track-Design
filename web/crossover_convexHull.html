<!DOCTYPE html>
<html lang="en">
<head>
  <title>Crossover ConvexHull</title>
  <script src="/src/lib/p5.js"></script>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <main>
    <form id="trackForm">
      <label for="seedInput1">Seed Parent 1:</label>
      <input type="text" id="seedInput1" name="seedInput1">
      <label for="cellCountInput1"># points for hull of Parent 1 (default 25):</label>
      <input type="text" id="cellCountInput1" name="cellCountInput1">
      
      <label for="seedInput2">Seed Parent 2:</label>
      <input type="text" id="seedInput2" name="seedInput2">
      <label for="cellCountInput2"># points for hull of Parent 2 (default 25):</label>
      <input type="text" id="cellCountInput2" name="cellCountInput2">

      <button type="submit">Generate Tracks</button>
    </form>
    <div>
      <label><input type="checkbox" id="showPoints" checked> Show Points</label>
      <label><input type="checkbox" id="showSpline" checked> Show Spline</label>
    </div>
    <div class="canvas-container">
      <div id="parent1"></div>
      <div id="parent2"></div>
      <div id="crossover"></div>
    </div>
  </main>

  <script type="module">
    import { generateTrack } from '../src/trackGen/trackGenerator.js';
import { crossover } from '../src/genetic/crossoverConvexHull.js';

// Constants and global variables
const BBOX = { xl: 0, xr: 600, yt: 0, yb: 600 };
const COLORS = {
  POINTS: [255, 255, 255, 150],   // White with opacity
  BACKGROUND: [18, 18, 18],       // Dark Grey (Material Design background)
  SPLINE: [
    [88, 86, 214],   // Soft Blue (inspired by Apple iOS)
    [255, 45, 85],   // Vibrant Coral (inspired by Apple iOS)
    [103, 58, 183],  // Deep Purple (from Material Design)
    [255, 196, 0]    // Warm Yellow (from Material Design)
  ],
  SEPARATION_LINE: [255, 0, 0]    // Red for separation line
};

let trackGenerators = {
  parent1: null,
  parent2: null,
  crossover: null
};

let p5Instances = {};
let lineParameters = null;

// DOM-related functions
function setupEventListeners() {
  document.getElementById('trackForm').addEventListener('submit', handleFormSubmit);
  document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
    checkbox.addEventListener('change', redrawAllCanvases);
  });
}

function handleFormSubmit(event) {
  event.preventDefault();
  const seed1 = parseFloat(document.getElementById('seedInput1').value);
  const trackSize1 = parseInt(document.getElementById('cellCountInput1').value);
  const seed2 = parseFloat(document.getElementById('seedInput2').value);
  const trackSize2 = parseInt(document.getElementById('cellCountInput2').value);

  clearCanvases();
  genTrack('parent1', isNaN(seed1) ? Math.random() : seed1, isNaN(trackSize1) ? 25 : trackSize1);
  genTrack('parent2', isNaN(seed2) ? Math.random() : seed2, isNaN(trackSize2) ? 25 : trackSize2);
  genTrack('crossover', -1, -1);
}

// Track generation and canvas setup
async function genTrack(canvasId, seed, trackSize) {
  let trackResult;
  if (canvasId === 'crossover') {
    await Promise.all([trackGenerators.parent1, trackGenerators.parent2]);
    const parent1 = trackGenerators.parent1;
    const parent2 = trackGenerators.parent2;
    
    let result = crossover(parent1, parent2);
    const crossoverDataSet = result.ds;
    lineParameters = result.lineParameters;
    
    trackResult = await generateTrack("convexHull", BBOX, seed, trackSize, false, crossoverDataSet);
  } else {
    trackResult = await generateTrack("convexHull", BBOX, seed, trackSize);
  }
  
  setupCanvas(canvasId, trackResult.generator, trackResult.track);
  trackGenerators[canvasId] = trackResult.generator;
}

function setupCanvas(containerId, trackGenerator, splineTrack) {
  p5Instances[containerId] = new p5((sketch) => {
    sketch.setup = () => {
      sketch.createCanvas(BBOX.xr, BBOX.yb).parent(containerId);
      sketch.frameRate(30);
      sketch.loop();
    };
    sketch.draw = () => drawCanvas(sketch, trackGenerator, splineTrack, containerId === 'crossover');
  });
}

// Drawing functions
function drawCanvas(sketch, trackGenerator, splineTrack, isCrossover) {
  sketch.background(COLORS.BACKGROUND);

  if (document.getElementById('showPoints').checked) drawPoints(sketch, trackGenerator.dataSet);
  if (document.getElementById('showSpline').checked) drawAnimatedSpline(sketch, splineTrack);
  if (isCrossover && lineParameters) drawSeparationLine(sketch, lineParameters);
}

function drawPoints(sketch, dataSet) {
  if (!dataSet) return;
  sketch.fill(COLORS.POINTS);
  sketch.noStroke();
  dataSet.forEach(pt => sketch.ellipse(pt.x, pt.y, 5, 5));
}

function drawAnimatedSpline(sketch, splineTrack) {
  if (!splineTrack) return;

  sketch.beginShape();
  for (let i = 0; i < splineTrack.length; i++) {
    let t = (i / splineTrack.length + sketch.frameCount * 0.02) % 1;
    t = (t + 1) % 1; // Ensure t is always positive
    
    let colorIndex = Math.floor(t * COLORS.SPLINE.length);
    let nextColorIndex = (colorIndex + 1) % COLORS.SPLINE.length;
    let colorT = (t * COLORS.SPLINE.length) % 1;
    
    let c = sketch.lerpColor(
      sketch.color(...COLORS.SPLINE[colorIndex]), 
      sketch.color(...COLORS.SPLINE[nextColorIndex]), 
      colorT
    );
    
    sketch.stroke(c);
    sketch.strokeWeight(3);
    sketch.point(splineTrack[i].x, splineTrack[i].y);
  }
  sketch.endShape(sketch.CLOSE);
}

function drawSeparationLine(sketch, lineParams) {
  const { slope, intercept } = lineParams;
  const x1 = 0;
  const y1 = slope * x1 + intercept;
  const x2 = sketch.width;
  const y2 = slope * x2 + intercept;
  sketch.strokeWeight(2);
  sketch.stroke(COLORS.SEPARATION_LINE);
  sketch.line(x1, y1, x2, y2);
}

// Utility functions
function clearCanvases() {
  Object.values(p5Instances).forEach(instance => instance.remove());
  p5Instances = {};
  ['parent1', 'parent2', 'crossover'].forEach(id => {
    document.getElementById(id).innerHTML = '';
  });
}

function redrawAllCanvases() {
  Object.values(p5Instances).forEach(instance => instance.redraw());
}

// Initialization
document.addEventListener('DOMContentLoaded', setupEventListeners);
  
    
  </script>
</body>
</html>