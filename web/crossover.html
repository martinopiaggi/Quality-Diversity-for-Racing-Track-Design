<!DOCTYPE html>
<html lang="en">
<head>
  <title>Crossover Lab</title>
  <script src="/src/lib/p5.js"></script>
  <script src="/src/lib/rhill-voronoi-core.js"></script>
  <style>
      body {
        font-family: Roboto, sans-serif;
        line-height: 1.6;
        background-color: #f8f8f8;
        color: #333;
        margin: 0;
        padding: 0;
      }
    .container {
      margin: 0 auto;
      padding: 20px;
      justify-content: center;
      max-width: 70%;
    }

    .content {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
    }

    header {
      text-align: center;
      margin-bottom: 2rem;
    }

    h1 {
      font-size: 2rem;
      color: #333;
    }

    .canvas-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 2rem;
      width: 100%;
      max-width: 100%;
    }

    .canvas-wrapper {
      position: relative;
      width: 100%;
      padding-bottom: 100%;
      margin-top:10px;
    }

    .canvas-wrapper canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .controls-wrapper {
      display: flex;
      justify-content: center;
      width: 100%;
    }

    .controls {
      position: relative;
      width: 100%;
      max-width: 400px;
      background-color: #fff;
      border-radius: 8px;
      padding: 1.5rem;
    }

    form {
      display: grid;
      gap: 1rem;
    }

    label {
      font-weight: bold;
      color: #333;
    }

    input[type="text"], 
    select {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    button {
      border: none;
      padding: 0.5rem 1rem;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color 0.3s ease;
    }

    .checkbox-group {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1rem;
    }

    .checkbox-group label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    @media screen and (min-width: 992px) {
      .container {
        flex-direction: row;
        justify-content: space-between;
        align-items: flex-start;
      }

    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Crossover Lab</h1>
    </header>
    <div class="content">
      <div class="controls-wrapper">
        <div class="controls">
          <form id="trackForm">
          <div style="display: flex; flex-wrap: wrap; gap: 1rem; align-items: center;">
              
            <label for="seedInput1">Enter Seed for Parent 1:</label>
            <input type="text" id="seedInput1" name="seedInput1">
            
            
            <label for="seedInput2">Enter Seed for Parent 2:</label>
            <input type="text" id="seedInput2" name="seedInput2">
            
            <label for="cellCountInput1">Enter Number of Cell Tracks for Parent 1:</label>
              <input type="text" id="cellCountInput1" name="cellCountInput1" style="flex: 1;">
              <label for="cellCountInput2">Enter Number of Cell Tracks for Parent 2:</label>
              <input type="text" id="cellCountInput2" name="cellCountInput2" style="flex: 1;">
            </div>
            <label for="crossoverMethod">Crossover Method:</label>
            <select id="crossoverMethod" name="crossoverMethod">
              <option value="voronoi">Voronoi</option>
              <option value="convexHull">Convex Hull</option>
            </select>
            <button type="submit">Generate Tracks</button>
          </form>
          <div>
            <label><input type="checkbox" id="showVoronoi" checked> Show Voronoi/Convex Hull</label>
            <label><input type="checkbox" id="showPoints" checked> Show Points</label>
            <label><input type="checkbox" id="showEdges" checked> Show Edges</label>
            <label><input type="checkbox" id="showSpline" checked> Show Spline</label>
            <label><input type="checkbox" id="regularize"> Regularize</label>
          </div>
        </div>
      </div>
      <div class="canvas-container">
        <div class="canvas-wrapper" id="parent1"></div>
        <div class="canvas-wrapper" id="parent2"></div>
        <div class="canvas-wrapper" id="crossover"></div>
      </div>
    </div>
  </div>
  <script type="module">
    import { generateTrack } from '../src/trackGen/trackGenerator.js';
    import { crossover as voronoiCrossover, crossover2 as voronoiCrossover2, crossover3 as voronoiCrossover3 } from '../src/genetic/crossoverVoronoi.js';
    import { crossover as convexHullCrossover } from '../src/genetic/crossoverConvexHull.js';

// Constants and global variables
const BBOX = { xl: 0, xr: 600, yt: 0, yb: 600 };
    const COLORS = {
      VORONOI: [76, 175, 80],    // Green  
      POINTS: [33, 150, 243],    // Blue
      EDGES: [255, 152, 0],      // Orange
      SELECTED: [103, 58, 183],  // Purple
      BACKGROUND: [248, 248, 248],  // Light Gray
      SPLINE: [
        [76, 175, 80],   // Green 
        [33, 150, 243],  // Blue
        [255, 152, 0],   // Orange  
        [156, 39, 176]   // Purple
      ],
      SEPARATION_LINE: [244, 67, 54]  // Red
    };

let trackGenerators = {
  parent1: null,
  parent2: null,
  crossover: null
};

let p5Instances = {};
let lineParameters = null;

// DOM-related functions
function setupEventListeners() {
  document.getElementById('trackForm').addEventListener('submit', handleFormSubmit);
  document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
    checkbox.addEventListener('change', redrawAllCanvases);
  });
}

function handleFormSubmit(event) {
      event.preventDefault();
      const seed1 = parseFloat(document.getElementById('seedInput1').value);
      const trackSize1 = parseInt(document.getElementById('cellCountInput1').value);
      const seed2 = parseFloat(document.getElementById('seedInput2').value);
      const trackSize2 = parseInt(document.getElementById('cellCountInput2').value);
      const crossoverMethod = document.getElementById('crossoverMethod').value;

      clearCanvases();
      genTrack('parent1', isNaN(seed1) ? Math.random() : seed1, isNaN(trackSize1) ? 3 : trackSize1, crossoverMethod);
      genTrack('parent2', isNaN(seed2) ? Math.random() : seed2, isNaN(trackSize2) ? 3 : trackSize2, crossoverMethod);
      genTrack('crossover', -1, -1, crossoverMethod);
    }


// Track generation and canvas setup
async function genTrack(canvasId, seed, trackSize, crossoverMethod) {
      const mode = crossoverMethod === 'voronoi' ? 'voronoi' : 'convexHull';
      const defaultTrackSize = mode === 'voronoi' ? 3 : 25;
      trackSize = isNaN(trackSize) ? defaultTrackSize : trackSize;

      let trackResult;
      if (canvasId === 'crossover') {
        await Promise.all([trackGenerators.parent1, trackGenerators.parent2]);
        const parent1 = trackGenerators.parent1;
        const parent2 = trackGenerators.parent2;
        
        let result;
        if (mode === 'voronoi') {
          const regularize = document.getElementById('regularize').checked;
          switch (crossoverMethod) {
            case 'voronoi':
              result = voronoiCrossover(parent1, parent2, regularize);
              lineParameters = result.lineParameters;
              break;
            case 'voronoi2':
              result = voronoiCrossover2(parent1, parent2, regularize);
              lineParameters = null;
              break;
            case 'voronoi3':
              result = voronoiCrossover3(parent1, parent2);
              lineParameters = null;
              break;
          }
        } else {
          result = convexHullCrossover(parent1, parent2);
          lineParameters = result.lineParameters;
        }
        
        trackResult = await generateTrack(mode, BBOX, seed, trackSize, false, result.ds, result.sel);
      } else {
        trackResult = await generateTrack(mode, BBOX, seed, trackSize);
      }
      
      setupCanvas(canvasId, trackResult.generator, trackResult.track);
      trackGenerators[canvasId] = trackResult.generator;
    }

function setupCanvas(containerId, trackGenerator, splineTrack) {
      p5Instances[containerId] = new p5((sketch) => {
        sketch.setup = () => {
          sketch.createCanvas(600, 600).parent(containerId);
          sketch.frameRate(30);
          sketch.loop();
        };
        sketch.draw = () => drawCanvas(sketch, trackGenerator, splineTrack, containerId === 'crossover');
      });
    }

// Drawing functions
function drawCanvas(sketch, trackGenerator, splineTrack, isCrossover) {
  sketch.background(COLORS.BACKGROUND);

  if (document.getElementById('showVoronoi').checked) drawVoronoi(sketch, trackGenerator.diagram);
  if (document.getElementById('showPoints').checked) drawPoints(sketch, trackGenerator.dataSet);
  if (document.getElementById('showEdges').checked) drawOriginalEdges(sketch, trackGenerator.trackEdges);
  if (document.getElementById('showSpline').checked) drawAnimatedSpline(sketch, splineTrack);
  if (isCrossover && lineParameters) drawSeparationLine(sketch, lineParameters);
}

function drawVoronoi(sketch, diagram) {
  sketch.strokeWeight(1);
  if (!diagram) return;
  sketch.stroke(COLORS.VORONOI);
  diagram.edges.forEach(edge => {
    sketch.line(edge.va.x, edge.va.y, edge.vb.x, edge.vb.y);
  });
  sketch.strokeWeight(1);
}

function drawPoints(sketch, dataSet) {
  if (!dataSet) return;
  sketch.fill(COLORS.POINTS);
  sketch.noStroke();
  dataSet.forEach(pt => sketch.ellipse(pt.x, pt.y, 5, 5));
}

function drawOriginalEdges(sketch, trackEdges) {
  sketch.strokeWeight(1);
  if (!trackEdges) return;
  sketch.stroke(COLORS.EDGES);
  sketch.strokeWeight(2);
  for (let i = 0; i < trackEdges.length; i++) {
    let nextIndex = (i + 1) % trackEdges.length;
    sketch.line(trackEdges[i].x, trackEdges[i].y, trackEdges[nextIndex].x, trackEdges[nextIndex].y);
  }
  sketch.strokeWeight(1);
}

function drawAnimatedSpline(sketch, splineTrack) {
  if (!splineTrack) return;

  sketch.beginShape();
  for (let i = 0; i < splineTrack.length; i++) {
    let t = (i / splineTrack.length + sketch.frameCount * 0.02) % 1;
    t = (t + 1) % 1; // Ensure t is always positive
    
    let colorIndex = Math.floor(t * COLORS.SPLINE.length);
    let nextColorIndex = (colorIndex + 1) % COLORS.SPLINE.length;
    let colorT = (t * COLORS.SPLINE.length) % 1;
    
    let c = sketch.lerpColor(
      sketch.color(...COLORS.SPLINE[colorIndex]), 
      sketch.color(...COLORS.SPLINE[nextColorIndex]), 
      colorT
    );
    
    sketch.stroke(c);
    sketch.strokeWeight(3);
    sketch.point(splineTrack[i].x, splineTrack[i].y);
  }
  sketch.endShape(sketch.CLOSE);
}

function drawSeparationLine(sketch, lineParams) {
  sketch.strokeWeight(2);
  const { slope, intercept } = lineParams;
  const x1 = 0;
  const y1 = slope * x1 + intercept;
  const x2 = sketch.width;
  const y2 = slope * x2 + intercept;
  sketch.strokeWeight(2);
  sketch.stroke(COLORS.SEPARATION_LINE);
  sketch.line(x1, y1, x2, y2);
  sketch.strokeWeight(1);
}

// Utility functions
function clearCanvases() {
  Object.values(p5Instances).forEach(instance => instance.remove());
  p5Instances = {};
  ['parent1', 'parent2', 'crossover'].forEach(id => {
    document.getElementById(id).innerHTML = '';
  });
}

function redrawAllCanvases() {
  Object.values(p5Instances).forEach(instance => instance.redraw());
}

// Initialization
document.addEventListener('DOMContentLoaded', setupEventListeners);
    
  </script>
</body>
</html>
